// 문제요약: 고속도로에 설치해야 하는 CCTV 수의 최솟값
// 알고리즘 선택: 
//  최솟값을 구하는 최적문제이므로 dp 의심
//  고려해야하는 상태: 자동차의 수, 현재 자동차, cctv 개수
//      dp[자동차의 수][현재 자동차]=cctv 개수: 현재 고려된 자동차의 수가 i일 때, 현재 자동차 j를 설치 시 cctv의 최소 개수
//      문제는 모든 자동차를 고려해야 한다는 것, dp 식을 이렇게 세우면 현재 자동차에 대한 행동을 특정할 수 없음
//          예를 들어 현재 자동차를 고려대상에서 건너뛰는 건 안됨. 왜냐하면 어차피 나중에 무조건 고려해야 하기 때문
//          따라서 결국 모든 자동차를 선택해야 하고, 이 과정에서 자동차를 뒤로 순서를 조정하는 건 순열이나 마찬가지임
//          순열이라면 특정 상태에 도달하는 것이 이전의 상태에 영향을 받는다는 것을 알 수 있음
//          이 경우 각 부분문제들이 독립적이지 않기 때문에 dp 안됨
//  greedy 의심
//      cctv는 범위내에 하나만 설치되어 있으면 됨
//      나가는 지점에 cctv를 설치하면 중간에 있는 다른 차량들도 모두 해당 cctv에 포함됨
//      정렬이 필요함
//          만약 진입점을 기준으로 정렬하면?
//          만약 진출점을 기준으로 정렬하면?
//              [4, 5], [3, 7], [-1, 100] => 반례
//              진출점을 기준으로 정렬하면, 시작점을 알 수 없기 때문에 뒤에 나오는 범위가 이전 범위들의 진입점보다 더 작을 수 있음. 이 경우 뒤에 나오는 범위를 첫번째 진입점으로 했어야 함
// 부분문제분해: 
//  진입점을 기준으로 내림차순 정렬: 뒤에서부터 pop해서 사용
//  while routes:
//      route=routes.pop
//      if 현재 범위의 진출점 < route.진입점:
//          갱신

function solution(routes) {
    var answer = 1;
    
    routes = routes.sort((a, b) => b[1] - a[1]);
    
    let last = routes.pop()[1];
    
    while (routes.length) {
        const route = routes.pop();
        
        if (last < route[0]) {
            last = route[1];
            answer++;
        }
    }
    
    return answer;
}